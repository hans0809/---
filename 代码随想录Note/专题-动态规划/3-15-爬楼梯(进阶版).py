# 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

# 每次你可以爬nums[i]个台阶。你有多少种不同的方法可以爬到楼顶呢？

# 转换成背包问题： nums就是不同的物品，背包最大容量就是n，求恰好装满背包的不同方案数

# 假设有3阶，那么第一步走2阶，第二步走1阶是一种方案，第一步走1阶，第二步走2阶也是一种方案
# 因此，这是一个排列问题！
# 所以要外层遍历背包，内层遍历物品

def plt(m,n):
    """
    每次可走1步, 2步, ..., m步
    楼梯总共有n个阶梯
    # m=2时就是普通的爬楼梯问题
    """
    
    # 物品数就是m

    weights=[i+1 for i in range(m)]# 物品重量
    values=[i+1 for i in range(m)] # 用不到
    # 背包容量就是楼梯总阶数n

    # dp[j]：恰好走上到第j阶总的不同方案数
    dp=[0 for _ in range(n+1)]

    # 初始化：走上第0阶只有一种方案，那就是原地不动
    dp[0]=1

    for j in range(n+1):# 先遍历背包
        for i in range(m):# 再遍历物品
            if j<weights[i]:
                dp[j]=dp[j]
            else:
                dp[j]=dp[j]+dp[j-weights[i]]
    return dp[n]

# 也没有二维dp. 背包