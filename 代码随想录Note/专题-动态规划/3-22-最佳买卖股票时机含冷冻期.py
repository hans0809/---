# 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

# 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

# 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
# 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
# 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]



# 定义dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。

# j从0到3分别对应以下4个状态：

# 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
# 卖出股票状态，这里就有两种卖出股票状态
#   状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
#   状态三：今天卖出了股票
# 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)# 天数

        # 定义dp:
        # dp[i][0]：第i天为买入股票的状态时，能够获得的最大利润
        # dp[i][1]：第i天为卖出股票的状态，并且两天前就卖出了股票(说明已经度过了昨天的冷冻期)时，能够获得的最大利润
        # dp[i][2]：第i天为卖出股票的状态，并且正是第i天卖出时，能够获得的最大利润
        # dp[i][3]：第i天为冷冻期时，能够获得的最大利润
        dp=[[0 for _ in range(4)] for _ in range(n)]

        # 初始化
        # 第0天为买入股票的状态时，能够获得的最大利润为-prices[0]
        dp[0][0]=-prices[0]
        # 第0天为卖出股票的状态，并且两天前就卖出了股票，能够获得的最大利润为0（第0天不可能卖出股票）
        dp[0][1]=0
        # 第0天为卖出股票的状态，并且正是第0天卖出，能够获得的最大利润为0（第0天不可能卖出股票）
        dp[0][2]=0
        # 第0天为冷冻期，能够获得的最大利润为0（第0天不可能是冷冻期）
        dp[0][3]=0


        for i in range(1,n):
            # 第i天为买入股票的状态时，有两种情况：
            # 1.正是第i天买入股票，那么
            #     前一天有可能是处于卖出股票状态，并且度过了冷冻期(dp[i][0]=dp[i-1][1])-prices[i])
            #     或者前一天是冷冻期(dp[i][0]=dp[i-1][3])-prices[i])
            #  取较大的
            # 2.之前就已经买入了股票，只是还没有执行操作而已：dp[i][0]=dp[i-1][0]
            dp[i][0]=max(max(dp[i-1][1]-prices[i], dp[i-1][3]-prices[i]),dp[i-1][0])

            # 第i天为卖出股票的状态，并且两天前就卖出了股票，有两种情况：
            # 1.前一天就已经是卖出股票的状态，那么dp[i][1]=dp[i-1][1]
            # 2.前一天是冷冻期(两天前卖出，前一天是冷冻期)：dp[i][1]=dp[i-1][3]
            dp[i][1]=max(dp[i-1][1],dp[i-1][3])

            # 第i天为卖出股票的状态，并且正是在第i天卖出的，那么前一天一定是买入状态：dp[i][2]=dp[i-1][0]+prices[i]
            dp[i][2]=dp[i-1][0]+prices[i]

            # 第i天是冷冻期，那么前一天一定是卖出状态并且正好是在前一天卖出：dp[i][3]=dp[i-1][2]
            dp[i][3]=dp[i-1][2]
        
        return max(dp[n-1][3],dp[n-1][2],dp[n-1][1])