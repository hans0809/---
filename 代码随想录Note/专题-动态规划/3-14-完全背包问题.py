# 完全背包问题的定义：有N件物品和一个最多能背重量为W的背包。
# 第i件物品的重量是weight[i]，得到的价值是value[i] 。
# 每件物品都有无限个（可以放入背包多次），求解将物品装入背包里能够获得的物品价值总和最大值。




# 在01背包问题中，每个物品只能拿一次，二维dp既可以先遍历物品再遍历背包，也可以反着，
# 一维dp必须先遍历物品再遍历背包，且倒序遍历背包（因为每个物品只能拿一次）

# 在完全背包中，每个物品可以拿无限次，二维dp既可以先遍历物品再遍历背包，也可以反着，
# 一维dp既可以先遍历物品再遍历背包，也可以反着，但一定要正序遍历背包（因为每个物品可以拿无限次）


# 二维dp
def complete_bag_2d(w,weights,values):
    n=len(weights)# 物品数

    # dp[i][j]: 第0...i-1件物品已经搞定，只考虑拿不拿第i件物品，在背包容量为j时，能获得的最大价值
    dp=[[0 for _ in range(w+1)] for _ in range(n)]

    # 初始化
    # # 当背包容量为0时，啥也装不下
    for i in range(n):
        dp[i][0]=0

    # 可有可无，因为同一个物品可以拿为无限次，后面还会更新
    #第0行，只考虑第0件物品时
    for j in range(w+1):
        if j>=weights[0]:
            dp[0][j]=values[0]
    
    for i in range(n):# 遍历物品, 必须从0开始：
        #（由于每个物品可以拿无限次，所以在只考虑第0件物品(物品0)时，
        # 拿2个或多个物品0(`背包容量j`大于等于`2个或多个物品0的重量`)比只拿1个物品0获得的价值更大，
        # 因此前面的初始化仅仅是初始化，还可能变化的，这一点和01背包不同，
        # 01背包中每个物品只能拿一次，因此初始化第0行时就被定死了，后续不会再变了）
        # 可以看到，对第0行的初始化可有可无~
        for j in range(w+1):# 遍历背包,可从0也可从1 开始
                            #（这一点和01背包一样，因为无论每个物品能拿几次，背包容量为0时能够获得的最大价值始终为0）
            # 如果当前版本容量j小于第i件物品的重量，只能选择不装第i件物品
            if j<weights[i]:
                dp[i][j]=dp[i-1][j]
            # 否则，可装可不装，取较大者
            else:# (这里要注意，其实完全背包二维数组的代码跟一维只有下面一个下标不同，
                 # 那就是“放i”这个选择，因为是可以重复放的，所以是dp[i])
                dp[i][j]=max(dp[i-1][j],dp[i][j-weights[i]]+values[i])
    return dp[n-1][w]


# ps：上述可能出现dp[-1][...]，但是取值为0，因为Python支持负数索引，最好是物品从1到n：（1，n+1）
# 而在01背包中，第0行被初始化后就不会再变了，因此for循环遍历物品直接从1开始，不会出现上述情况
# 这里最好是改成下面这种，物体下标从1开始，这样更准确:
def complete_bag_2d_(w,weights,values):
    n=len(weights)# 物品数

    # dp[i][j]: 第1...i-1件物品已经搞定，只考虑拿不拿第i件物品，在背包容量为j时，能获得的最大价值
    dp=[[0 for _ in range(w+1)] for _ in range(n+1)]

    # 初始化
    # # 当背包容量为0时，啥也装不下
    for i in range(1, n+1):
        dp[i][0]=0
    #第0行，只考虑第1件物品时
    for j in range(w+1):
        if j>=weights[0]:
            dp[1][j]=values[0]
    
    for i in range(1, n+1):# 遍历物品, 必须从第一个物品开始：(这里是1，因为这里的物品下标从1到n)
        #（由于每个物品可以拿无限次，所以在只考虑第0件物品(物品0)时，
        # 拿2个或多个物品1(`背包容量j`大于等于`2个或多个物品0的重量`)比只拿1个物品1获得的价值更大，
        # 因此前面的初始化仅仅是初始化，还可能变化的，这一点和01背包不同，
        # 01背包中每个物品只能拿一次，因此初始化第0行时就被定死了，后续不会再变了）
        # 可以看到，对第0行的初始化可有可无~
        for j in range(w+1):# 遍历背包,可从0也可从1 开始
                            #（这一点和01背包一样，因为无论每个物品能拿几次，背包容量为0时能够获得的最大价值始终为0）
            # 如果当前版本容量j小于第i件物品的重量，只能选择不装第i件物品
            if j<weights[i-1]:
                dp[i][j]=dp[i-1][j]
            # 否则，可装可不装，取较大者
            else:# (这里要注意，其实完全背包二维数组的代码跟一维只有下面一个下标不同，
                 # 那就是“放i”这个选择，因为是可以重复放的，所以是dp[i])
                dp[i][j]=max(dp[i-1][j],dp[i][j-weights[i-1]]+values[i-1])
    return dp[n][w]



# 一维dp
def complete_bag(w,weights,values):
    n=len(weights)# 物品数
    dp = [0]*(w + 1)#dp[i]: 背包容量为i时能够获得的最大价值
    dp[0]=0# 背包容量为0时，啥也装不下
    for i in range(n):# 遍历物品,不能从1开始，否则报错。。。
        for j in range(0,w + 1):# 与01背包唯一的区别：正序遍历背包！
            if j<weights[i]:
                dp[j]=dp[j]
            else:
                dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
    return dp[w]

weights=[1,3,4]
values=[15,20,30]
w=4
print(complete_bag(w,weights,values))
print(complete_bag_2d(w,weights,values))
print(complete_bag_2d_(w,weights,values))