# 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

# 示例:

# nums = [1, 2, 3] target = 4

# 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)

# 请注意，顺序不同的序列被视作不同的组合。

# 因此输出为 7。

# 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
# 如果求排列数就是外层for遍历背包，内层for循环遍历物品。

# 本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，其实就是求排列！

# 数组所含数字不重复，且每个数字可用多次，因此是完全背包问题


# 一维dp
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        # 完全背包，求不同方案数
        # 是排列问题：先遍历背包，再遍历物品

        n=len(nums)# 物品数
        weights=nums# 物品重量
        values=nums# 物品价值，本题求方案数，用不到values
        # 背包最大容量为target

        # dp[j]：凑成j的排列方案数
        dp=[0 for _ in range(target+1)]

        # 初始化：目标为0时，啥也不用做就可以了，因此是1种方案
        dp[0]=1

        for j in range(target+1):# 遍历背包，正序遍历
            for i in range(n):#遍历物品
                if j<weights[i]:
                    dp[j]=dp[j]
                else:
                    dp[j]=dp[j]+dp[j-weights[i]]
        return dp[target]


# 二维dp:没有这种解法：

# 哈哈哈，尚能看到9.12每日一题的大型翻车现场。毕竟组合1-3都是dfs题，这题本质上不是dfs，翻车也不奇怪....

# 然后，针对这种特殊背包题，我的一些心得：

# 有没有二维dp的做法？
# 我一开始以为是0-1背包题，套模板写了个二维dp表，然后发现不对。这nm是求组合，这dp怎么更新？
# 后来卡住了就去看了题解，发现清一色的一位表。思考了一会儿得出了结论：不存在二维解法。

# 因为排列与组合的不同在于累加。换句话说，组合的答案其实是所有可能的排列加在一起。
# 也就是说，其实这里的一位dp并不是什么二维dp两行间的存储优化（上下降纬），而是二维dp中一列的求和，是左右的降纬。

# 为什么要把target循环放在外面？
# 结合上一个问题，既然二维dp被压缩成从左到右的一纬dp，那么我们更新的顺序也发生了变化。
# 我们首先要对target=0，计算出所有对应nums（即二维表中的行）的结果，并求和，再依次计算target=1， target=2....的求和。即，从左到右更新一维dp表，而不是传统背包题从上到下（宏观上）更新dp表。因此需要修改循环叠加方式。

# 这题真的是一道背包题吗？
# 个人认为此类求排序结果的“背包题”严格意义上来说不是背包题的范畴。
# 相反，它更像一个普通的动态规划题。如果我们把对背包题的知识全部放空，单纯把这题看做一个规模由大缩小，
# 通过分割重复子问题来解决宏问题的考题，反而更容易把转移方程想出来。
# 现在返过去重新审视这题，其实过分执着于背包模板，也是导致我一开始走了二维dp歪路的原因之一。

# 在0-1背包的二维dp中，dp数组是从上往下更新。完全背包的二维dp既跟上一层有关，有和本层有关，但排列数只和本层有关，
