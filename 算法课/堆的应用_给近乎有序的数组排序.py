# 给定一个近乎有序的数组。近乎有序是指，如果把数组排好序的话，每个元素移动的距离一定不超过k，
# 并且k相对于数组长度来说是比较小的，请选择一个合适的排序策略，对数组进行从小到大的排序。

# 使用堆排序对长度为n的数组进行排序时，每个元素最多移动logN次(建堆时从最下面移动到最上面，或者是建好堆后及逆行排序时从最上面移动到最下面，树的高度为logN)
# 总共N个元素，因此时间复杂度是O(NlogN)

# 如果维护一个长度为k的数组，并据此构建一个堆，那么这个堆中的每弹出一个元素最多移动logk次
# 并且只要弹出一个元素即可（弹出最小的，再加进来一个，始终维持堆中元素个数为k+1），因此总的时间复杂度是Nlogk

# 为什么能够这样做呢？因为题目说了每个元素在排序时的移动距离最多不超过k，
# 也就是说，堆中所含元素个数最多为k+1个

arr=[8,7,1,2,4,3]
k=3
def solver(arr,k):
    import heapq
    maxHeap=[]

    #利用前k+1个数构建一个堆，并进行堆排序，默认从小到大排序
    for i in range(min(len(arr)-1,k+1)):
        heapq.heappush(maxHeap, arr[i])
    
    #index跟踪下一次要入堆的元素下标
    index=k+1
    #i跟踪已经有序的数组范围(【左下标，右下标】)的右下标
    i=0
    while index<len(arr):
        arr[i]=heapq.heappop(maxHeap)#弹出一个最小的
        heapq.heappush(maxHeap, arr[index])#上面弹出一个，这里再补位一个

        i+=1#有序数组范围扩大1
        index+=1
    
    #如果最后堆中还有元素，那么就逐个弹出即可，因为这些元素就是按照从小到大排列的
    while (len(maxHeap)!=0):
        arr[i]=heapq.heappop(maxHeap)
        i+=1

print('排序前：',arr)      
solver(arr,k)
print('排序后：',arr)
"""
排序前： [8, 7, 1, 2, 4, 3]
排序后： [1, 2, 3, 4, 7, 8]
"""
    


